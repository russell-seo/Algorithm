# BFS(Breadth-First Search)

- 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘
- Queue 자료구조를 사용한다.

- 출발노드에서 목표 노드까지 최단 길이 경로를 보장한다.
- 깊이 탐색하기 전에 넓게 탐색한다.
- 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.


## 간단한 송아지 찾기 문제로 구현 해보자

>송아지 찾기 1(BFS : 상태트리탐색)
>
>설명
>
>현수는 송아지를 잃어버렸다. 다행히 송아지에는 위치추적기가 달려 있다.
>
>현수의 위치와 송아지의 위치가 수직선상의 좌표 점으로 주어지면 현수는 현재 위치에서 송아지의 위치까지 다음과 같은 방법으로 이동한다.
>
>송아지는 움직이지 않고 제자리에 있다.
>
>현수는 스카이 콩콩을 타고 가는데 한 번의 점프로 앞으로 1, 뒤로 1, 앞으로 5를 이동할 수 있다.
>
>최소 몇 번의 점프로 현수가 송아지의 위치까지 갈 수 있는지 구하는 프로그램을 작성하세요.


>입력
>
>첫 번째 줄에 현수의 위치 S와 송아지의 위치 E가 주어진다. 직선의 좌표 점은 1부터 10,000까지이다.


>출력
>
>점프의 최소횟수를 구한다. 답은 1이상이며 반드시 존재합니다.

>예시 입력 1
>
>5 14
>예시 출력 1
>
>3



~~~java

public void 송아지찾기(int a, int b){
    Queue<Integer> queue = new LinkedList<>();
    int[] ch = new int[10001];
    int[] dis = {1, -1, 5};
    int count = 0;

    queue.offer(a);

    while(!queue.isEmpty()){
       int size = queue.size();
       for(int i=0; i<size; i++){
          Integer c = queue.poll();
          for(int j=0; j<3; j++){
             int p = dis[j] + c;

             if(p==b) return count+1;
              ch[p] = 1;
              queue.offer(p);
          }
       }
        count++;
    }

}

~~~
